import { describe, it, expect, vi, beforeEach } from 'vitest'
import { renderHook } from '@testing-library/react'
import {
  TVulnerabilityFlag,
  TVulnerabilityFlagLabel,
  flagLabels,
  useVulnerabilityFlagGenerator,
} from '../../../../src/routes/vulnerabilities/types/tVulnerabilityFlag'
import { uid } from 'uid'

// Mock the uid module
vi.mock('uid', () => ({
  uid: vi.fn(() => 'mock-uid-123')
}))

// Mock the useTemplate hook
const mockGetTemplateDefaultObject = vi.fn()
vi.mock('@/utils/template', () => ({
  useTemplate: () => ({
    getTemplateDefaultObject: mockGetTemplateDefaultObject,
  }),
}))

const mockUid = vi.mocked(uid)

describe('tVulnerabilityFlag', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockUid.mockReturnValue('mock-uid-123')
    mockGetTemplateDefaultObject.mockReturnValue({})
  })

  describe('constants', () => {
    describe('flagLabels', () => {
      it('should export correct flag labels array', () => {
        expect(flagLabels).toEqual([
          'component_not_present',
          'inline_mitigations_already_exist',
          'vulnerable_code_cannot_be_controlled_by_adversary',
          'vulnerable_code_not_in_execute_path',
          'vulnerable_code_not_present',
        ])
      })

      it('should have exactly 5 flag labels', () => {
        expect(flagLabels).toHaveLength(5)
      })

      it('should be a readonly array', () => {
        // flagLabels is defined with 'as const' which makes it readonly
        // but at runtime, JavaScript arrays can still be mutated
        const originalLength = flagLabels.length
        expect(flagLabels).toHaveLength(originalLength)
        expect(Array.isArray(flagLabels)).toBe(true)
      })

      it('should contain only string values', () => {
        flagLabels.forEach(label => {
          expect(typeof label).toBe('string')
          expect(label.length).toBeGreaterThan(0)
        })
      })

      it('should have unique values', () => {
        const uniqueLabels = [...new Set(flagLabels)]
        expect(uniqueLabels).toHaveLength(flagLabels.length)
      })

      it('should contain expected specific labels', () => {
        expect(flagLabels).toContain('component_not_present')
        expect(flagLabels).toContain('inline_mitigations_already_exist')
        expect(flagLabels).toContain('vulnerable_code_cannot_be_controlled_by_adversary')
        expect(flagLabels).toContain('vulnerable_code_not_in_execute_path')
        expect(flagLabels).toContain('vulnerable_code_not_present')
      })

      it('should not contain any empty strings', () => {
        flagLabels.forEach(label => {
          expect(label).not.toBe('')
          expect(label.trim()).toBe(label)
        })
      })

      it('should use snake_case naming convention', () => {
        flagLabels.forEach(label => {
          expect(label).toMatch(/^[a-z_]+$/)
          expect(label).not.toContain(' ')
          expect(label).not.toContain('-')
          expect(label).not.toContain('.')
        })
      })
    })
  })

  describe('type definitions', () => {
    describe('TVulnerabilityFlagLabel', () => {
      it('should allow all values from flagLabels', () => {
        flagLabels.forEach(label => {
          const validLabel: TVulnerabilityFlagLabel = label
          expect(validLabel).toBe(label)
        })
      })

      it('should be derived from flagLabels array', () => {
        // This is more of a compile-time check, but we can verify the values
        const testLabel: TVulnerabilityFlagLabel = 'component_not_present'
        expect(flagLabels).toContain(testLabel)
      })
    })

    describe('TVulnerabilityFlag', () => {
      it('should define TVulnerabilityFlag type correctly with all required fields', () => {
        const validFlag: TVulnerabilityFlag = {
          id: 'test-flag-id',
          label: 'component_not_present',
          productIds: ['product-1', 'product-2'],
        }

        expect(validFlag.id).toBe('test-flag-id')
        expect(validFlag.label).toBe('component_not_present')
        expect(validFlag.productIds).toEqual(['product-1', 'product-2'])
      })

      it('should allow empty productIds array', () => {
        const flagWithEmptyProducts: TVulnerabilityFlag = {
          id: 'test-flag-id',
          label: 'vulnerable_code_not_present',
          productIds: [],
        }

        expect(flagWithEmptyProducts.productIds).toEqual([])
        expect(flagWithEmptyProducts.productIds).toHaveLength(0)
      })

      it('should allow multiple productIds', () => {
        const flagWithMultipleProducts: TVulnerabilityFlag = {
          id: 'test-flag-id',
          label: 'inline_mitigations_already_exist',
          productIds: ['prod-1', 'prod-2', 'prod-3', 'prod-4'],
        }

        expect(flagWithMultipleProducts.productIds).toHaveLength(4)
        expect(flagWithMultipleProducts.productIds).toContain('prod-1')
        expect(flagWithMultipleProducts.productIds).toContain('prod-4')
      })

      it('should allow all valid flag labels', () => {
        flagLabels.forEach(label => {
          const flag: TVulnerabilityFlag = {
            id: `test-${label}`,
            label: label,
            productIds: ['test-product'],
          }

          expect(flag.label).toBe(label)
          expect(flag.id).toContain(label)
        })
      })

      it('should require string id field', () => {
        const flag: TVulnerabilityFlag = {
          id: 'some-unique-identifier',
          label: 'component_not_present',
          productIds: [],
        }

        expect(typeof flag.id).toBe('string')
        expect(flag.id).toBe('some-unique-identifier')
      })

      it('should require productIds to be string array', () => {
        const flag: TVulnerabilityFlag = {
          id: 'test-id',
          label: 'component_not_present',
          productIds: ['product-a', 'product-b', 'product-c'],
        }

        expect(Array.isArray(flag.productIds)).toBe(true)
        flag.productIds.forEach(productId => {
          expect(typeof productId).toBe('string')
        })
      })

      it('should handle complex object structure', () => {
        const complexFlag: TVulnerabilityFlag = {
          id: 'complex-flag-123',
          label: 'vulnerable_code_cannot_be_controlled_by_adversary',
          productIds: [
            'product-with-long-name',
            'another-product-id',
            'third-product-identifier',
          ],
        }

        expect(Object.keys(complexFlag)).toEqual(['id', 'label', 'productIds'])
        expect(complexFlag).toHaveProperty('id')
        expect(complexFlag).toHaveProperty('label')
        expect(complexFlag).toHaveProperty('productIds')
      })
    })
  })

  describe('useVulnerabilityFlagGenerator', () => {
    describe('hook initialization', () => {
      it('should initialize without errors', () => {
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        
        expect(result.current).toBeDefined()
        expect(result.current.generateVulnerabilityFlag).toBeDefined()
        expect(typeof result.current.generateVulnerabilityFlag).toBe('function')
      })

      it('should call useTemplate hook', () => {
        renderHook(() => useVulnerabilityFlagGenerator())
        
        // The hook should have been called during render
        expect(mockGetTemplateDefaultObject).toHaveBeenCalledWith('vulnerabilities.flags')
      })

      it('should return an object with generateVulnerabilityFlag function', () => {
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        
        expect(result.current).toEqual({
          generateVulnerabilityFlag: expect.any(Function)
        })
      })
    })

    describe('generateVulnerabilityFlag function', () => {
      it('should generate a vulnerability flag with default values', () => {
        mockGetTemplateDefaultObject.mockReturnValue({})
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        const generatedFlag = result.current.generateVulnerabilityFlag()
        
        expect(generatedFlag).toEqual({
          id: 'mock-uid-123',
          label: 'component_not_present',
          productIds: [],
        })
      })

      it('should use template productIds when available', () => {
        mockGetTemplateDefaultObject.mockReturnValue({
          productIds: ['template-product-1', 'template-product-2']
        })
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        const generatedFlag = result.current.generateVulnerabilityFlag()
        
        expect(generatedFlag.productIds).toEqual(['template-product-1', 'template-product-2'])
      })

      it('should use template label when available', () => {
        mockGetTemplateDefaultObject.mockReturnValue({
          label: 'vulnerable_code_not_present'
        })
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        const generatedFlag = result.current.generateVulnerabilityFlag()
        
        expect(generatedFlag.label).toBe('vulnerable_code_not_present')
      })

      it('should use both template label and productIds when available', () => {
        mockGetTemplateDefaultObject.mockReturnValue({
          label: 'inline_mitigations_already_exist',
          productIds: ['prod-a', 'prod-b', 'prod-c']
        })
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        const generatedFlag = result.current.generateVulnerabilityFlag()
        
        expect(generatedFlag).toEqual({
          id: 'mock-uid-123',
          label: 'inline_mitigations_already_exist',
          productIds: ['prod-a', 'prod-b', 'prod-c'],
        })
      })

      it('should generate unique ids on multiple calls', () => {
        let callCount = 0
        mockUid.mockImplementation(() => `unique-id-${++callCount}`)
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        
        const flag1 = result.current.generateVulnerabilityFlag()
        const flag2 = result.current.generateVulnerabilityFlag()
        
        expect(flag1.id).toBe('unique-id-1')
        expect(flag2.id).toBe('unique-id-2')
        expect(flag1.id).not.toBe(flag2.id)
      })

      it('should handle empty template object', () => {
        mockGetTemplateDefaultObject.mockReturnValue({})
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        const generatedFlag = result.current.generateVulnerabilityFlag()
        
        expect(generatedFlag.id).toBe('mock-uid-123')
        expect(generatedFlag.label).toBe('component_not_present')
        expect(generatedFlag.productIds).toEqual([])
      })

      it('should handle null template values', () => {
        // The actual implementation will throw when accessing properties on null
        mockGetTemplateDefaultObject.mockReturnValue(null)
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        
        expect(() => {
          result.current.generateVulnerabilityFlag()
        }).toThrow()
      })

      it('should handle undefined template values', () => {
        // The actual implementation will throw when accessing properties on undefined  
        mockGetTemplateDefaultObject.mockReturnValue(undefined)
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        
        expect(() => {
          result.current.generateVulnerabilityFlag()
        }).toThrow()
      })

      it('should handle partial template data', () => {
        mockGetTemplateDefaultObject.mockReturnValue({
          label: 'vulnerable_code_not_in_execute_path'
          // productIds not provided
        })
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        const generatedFlag = result.current.generateVulnerabilityFlag()
        
        expect(generatedFlag.label).toBe('vulnerable_code_not_in_execute_path')
        expect(generatedFlag.productIds).toEqual([])
      })

      it('should handle template with only productIds', () => {
        mockGetTemplateDefaultObject.mockReturnValue({
          productIds: ['single-product']
          // label not provided
        })
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        const generatedFlag = result.current.generateVulnerabilityFlag()
        
        expect(generatedFlag.label).toBe('component_not_present')
        expect(generatedFlag.productIds).toEqual(['single-product'])
      })

      it('should always call uid() to generate new id', () => {
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        
        result.current.generateVulnerabilityFlag()
        result.current.generateVulnerabilityFlag()
        
        expect(mockUid).toHaveBeenCalledTimes(2)
      })

      it('should return valid TVulnerabilityFlag type', () => {
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        const generatedFlag = result.current.generateVulnerabilityFlag()
        
        // Type validation
        expect(typeof generatedFlag.id).toBe('string')
        expect(typeof generatedFlag.label).toBe('string')
        expect(Array.isArray(generatedFlag.productIds)).toBe(true)
        expect(flagLabels).toContain(generatedFlag.label)
        
        // Structure validation
        expect(Object.keys(generatedFlag)).toEqual(['id', 'productIds', 'label'])
        expect(generatedFlag).toHaveProperty('id')
        expect(generatedFlag).toHaveProperty('label')
        expect(generatedFlag).toHaveProperty('productIds')
      })
    })

    describe('hook stability', () => {
      it('should return stable function reference', () => {
        const { result, rerender } = renderHook(() => useVulnerabilityFlagGenerator())
        
        const firstFunction = result.current.generateVulnerabilityFlag
        
        rerender()
        
        const secondFunction = result.current.generateVulnerabilityFlag
        
        // The function is not stable as it's created on each hook call,
        // but it should work consistently
        expect(typeof firstFunction).toBe('function')
        expect(typeof secondFunction).toBe('function')
        
        // Test that both functions work the same way
        const flag1 = firstFunction()
        const flag2 = secondFunction()
        
        expect(flag1.label).toBe(flag2.label)
        expect(flag1.productIds).toEqual(flag2.productIds)
      })

      it('should maintain functionality across re-renders', () => {
        const { result, rerender } = renderHook(() => useVulnerabilityFlagGenerator())
        
        const flag1 = result.current.generateVulnerabilityFlag()
        
        rerender()
        
        const flag2 = result.current.generateVulnerabilityFlag()
        
        expect(flag1).toEqual({
          id: 'mock-uid-123',
          label: 'component_not_present',
          productIds: [],
        })
        
        expect(flag2).toEqual({
          id: 'mock-uid-123',
          label: 'component_not_present',
          productIds: [],
        })
      })
    })

    describe('template integration', () => {
      it('should call getTemplateDefaultObject with correct key', () => {
        renderHook(() => useVulnerabilityFlagGenerator())
        
        expect(mockGetTemplateDefaultObject).toHaveBeenCalledWith('vulnerabilities.flags')
        expect(mockGetTemplateDefaultObject).toHaveBeenCalledTimes(1)
      })

      it('should handle template errors gracefully', () => {
        mockGetTemplateDefaultObject.mockImplementation(() => {
          throw new Error('Template error')
        })
        
        expect(() => {
          renderHook(() => useVulnerabilityFlagGenerator())
        }).toThrow('Template error')
      })

      it('should work with different template configurations', () => {
        const templateConfigs = [
          {},
          { label: 'component_not_present' },
          { productIds: [] },
          { productIds: ['test'] },
          { label: 'vulnerable_code_not_present', productIds: ['p1', 'p2'] },
        ]
        
        templateConfigs.forEach(config => {
          mockGetTemplateDefaultObject.mockReturnValue(config)
          
          const { result } = renderHook(() => useVulnerabilityFlagGenerator())
          const flag = result.current.generateVulnerabilityFlag()
          
          expect(flag).toBeDefined()
          expect(flag.id).toBeDefined()
          expect(flag.label).toBeDefined()
          expect(flag.productIds).toBeDefined()
          expect(flagLabels).toContain(flag.label)
        })
      })
    })

    describe('edge cases', () => {
      it('should handle template returning non-object', () => {
        mockGetTemplateDefaultObject.mockReturnValue(null)
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        
        expect(() => {
          result.current.generateVulnerabilityFlag()
        }).toThrow()
      })

      it('should handle template returning undefined', () => {
        mockGetTemplateDefaultObject.mockReturnValue(undefined)
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        
        expect(() => {
          result.current.generateVulnerabilityFlag()
        }).toThrow()
      })

      it('should handle template with invalid label type', () => {
        mockGetTemplateDefaultObject.mockReturnValue({
          label: 123, // invalid type - will be used as-is in the actual implementation
          productIds: ['valid-product']
        })
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        const generatedFlag = result.current.generateVulnerabilityFlag()
        
        // The actual implementation uses the value as-is without type checking
        expect(generatedFlag.label).toBe(123)
        expect(generatedFlag.productIds).toEqual(['valid-product'])
      })

      it('should handle template with invalid productIds type', () => {
        mockGetTemplateDefaultObject.mockReturnValue({
          label: 'vulnerable_code_not_present',
          productIds: 'not-an-array' // invalid type - will be used as-is
        })
        
        const { result } = renderHook(() => useVulnerabilityFlagGenerator())
        const generatedFlag = result.current.generateVulnerabilityFlag()
        
        expect(generatedFlag.label).toBe('vulnerable_code_not_present')
        // The actual implementation uses the value as-is without type checking
        expect(generatedFlag.productIds).toBe('not-an-array')
      })
    })
  })

  describe('integration tests', () => {
    it('should work with realistic data flow', () => {
      // Simulate realistic template data
      mockGetTemplateDefaultObject.mockReturnValue({
        label: 'inline_mitigations_already_exist',
        productIds: ['product-server-2023', 'product-client-web', 'product-mobile-app']
      })
      
      mockUid.mockReturnValue('vulnerability-flag-abc123def456')
      
      const { result } = renderHook(() => useVulnerabilityFlagGenerator())
      const flag = result.current.generateVulnerabilityFlag()
      
      expect(flag).toEqual({
        id: 'vulnerability-flag-abc123def456',
        label: 'inline_mitigations_already_exist',
        productIds: ['product-server-2023', 'product-client-web', 'product-mobile-app']
      })
      
      // Verify the flag can be used as a proper TVulnerabilityFlag
      const validFlag: TVulnerabilityFlag = flag
      expect(validFlag.id).toBe('vulnerability-flag-abc123def456')
    })

    it('should generate multiple different flags', () => {
      let idCounter = 0
      mockUid.mockImplementation(() => `flag-${++idCounter}`)
      
      const templateData = [
        { label: 'component_not_present', productIds: ['p1'] },
        { label: 'vulnerable_code_not_present', productIds: ['p2', 'p3'] },
        { label: 'vulnerable_code_not_in_execute_path', productIds: [] },
      ]
      
      const { result } = renderHook(() => useVulnerabilityFlagGenerator())
      const flags: TVulnerabilityFlag[] = []
      
      templateData.forEach(template => {
        mockGetTemplateDefaultObject.mockReturnValue(template)
        
        // Re-render the hook to pick up new template data
        const { result: newResult } = renderHook(() => useVulnerabilityFlagGenerator())
        flags.push(newResult.current.generateVulnerabilityFlag())
      })
      
      expect(flags).toHaveLength(3)
      expect(flags[0].id).toBe('flag-1')
      expect(flags[1].id).toBe('flag-2')
      expect(flags[2].id).toBe('flag-3')
      
      expect(flags[0].label).toBe('component_not_present')
      expect(flags[1].label).toBe('vulnerable_code_not_present')
      expect(flags[2].label).toBe('vulnerable_code_not_in_execute_path')
    })
  })
})