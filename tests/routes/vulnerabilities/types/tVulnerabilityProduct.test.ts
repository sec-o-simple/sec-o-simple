import { describe, it, expect, vi, beforeEach } from 'vitest'
import { renderHook } from '@testing-library/react'
import {
  TVulnerabilityProduct,
  TProductStatus,
  productStatus,
  useVulnerabilityProductGenerator,
} from '../../../../src/routes/vulnerabilities/types/tVulnerabilityProduct'
import { uid } from 'uid'

// Mock the uid module
vi.mock('uid', () => ({
  uid: vi.fn(() => 'mock-uid-123')
}))

// Mock the useTemplate hook
const mockGetTemplateDefaultObject = vi.fn()
vi.mock('@/utils/template', () => ({
  useTemplate: () => ({
    getTemplateDefaultObject: mockGetTemplateDefaultObject,
  }),
}))

const mockUid = vi.mocked(uid)

describe('tVulnerabilityProduct', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockUid.mockReturnValue('mock-uid-123')
    mockGetTemplateDefaultObject.mockReturnValue({})
  })

  describe('type definitions', () => {
    it('should define TVulnerabilityProduct type correctly', () => {
      const validProduct: TVulnerabilityProduct = {
        id: 'test-id',
        productId: 'product-123',
        status: 'known_affected',
      }

      expect(validProduct.id).toBe('test-id')
      expect(validProduct.productId).toBe('product-123')
      expect(validProduct.status).toBe('known_affected')
    })

    it('should allow empty string for status', () => {
      const productWithEmptyStatus: TVulnerabilityProduct = {
        id: 'test-id',
        productId: 'product-123',
        status: '',
      }

      expect(productWithEmptyStatus.status).toBe('')
    })

    it('should allow all valid TProductStatus values', () => {
      productStatus.forEach(status => {
        const product: TVulnerabilityProduct = {
          id: 'test-id',
          productId: 'product-123',
          status: status,
        }
        expect(product.status).toBe(status)
      })
    })
  })

  describe('productStatus constant', () => {
    it('should export correct productStatus array', () => {
      const expectedStatuses = [
        'first_affected',
        'known_affected',
        'known_not_affected',
        'last_affected',
        'first_fixed',
        'fixed',
        'recommended',
        'under_investigation',
      ]

      expect(productStatus).toEqual(expectedStatuses)
      expect(productStatus).toHaveLength(8)
    })

    it('should be a readonly array', () => {
      // TypeScript ensures this at compile time with 'as const'
      expect(Array.isArray(productStatus)).toBe(true)
      expect(productStatus.length).toBe(8)
    })

    it('should contain all expected status values', () => {
      expect(productStatus).toContain('first_affected')
      expect(productStatus).toContain('known_affected')
      expect(productStatus).toContain('known_not_affected')
      expect(productStatus).toContain('last_affected')
      expect(productStatus).toContain('first_fixed')
      expect(productStatus).toContain('fixed')
      expect(productStatus).toContain('recommended')
      expect(productStatus).toContain('under_investigation')
    })

    it('should not contain duplicate values', () => {
      const uniqueStatuses = [...new Set(productStatus)]
      expect(uniqueStatuses).toHaveLength(productStatus.length)
    })
  })

  describe('TProductStatus type', () => {
    it('should derive from productStatus array', () => {
      // This is tested implicitly through the type system
      // All productStatus values should be valid TProductStatus values
      const allValidStatuses: TProductStatus[] = [
        'first_affected',
        'known_affected',
        'known_not_affected',
        'last_affected',
        'first_fixed',
        'fixed',
        'recommended',
        'under_investigation',
      ]

      allValidStatuses.forEach(status => {
        expect(productStatus).toContain(status)
      })
    })
  })

  describe('useVulnerabilityProductGenerator', () => {
    it('should return an object with generateVulnerabilityProduct function', () => {
      const { result } = renderHook(() => useVulnerabilityProductGenerator())

      expect(result.current).toHaveProperty('generateVulnerabilityProduct')
      expect(typeof result.current.generateVulnerabilityProduct).toBe('function')
    })

    it('should call getTemplateDefaultObject with correct path', () => {
      renderHook(() => useVulnerabilityProductGenerator())

      expect(mockGetTemplateDefaultObject).toHaveBeenCalledWith('vulnerabilities.products')
    })

    it('should generate vulnerability product with uid', () => {
      mockUid.mockReturnValue('test-uid-456')
      const { result } = renderHook(() => useVulnerabilityProductGenerator())

      const product = result.current.generateVulnerabilityProduct()

      expect(product.id).toBe('test-uid-456')
      expect(mockUid).toHaveBeenCalledOnce()
    })

    it('should generate vulnerability product with empty productId', () => {
      const { result } = renderHook(() => useVulnerabilityProductGenerator())

      const product = result.current.generateVulnerabilityProduct()

      expect(product.productId).toBe('')
    })

    it('should use template default status when available', () => {
      mockGetTemplateDefaultObject.mockReturnValue({
        status: 'known_affected',
      })

      const { result } = renderHook(() => useVulnerabilityProductGenerator())
      const product = result.current.generateVulnerabilityProduct()

      expect(product.status).toBe('known_affected')
    })

    it('should use empty string for status when template default is undefined', () => {
      mockGetTemplateDefaultObject.mockReturnValue({})

      const { result } = renderHook(() => useVulnerabilityProductGenerator())
      const product = result.current.generateVulnerabilityProduct()

      expect(product.status).toBe('')
    })

    it('should use empty string for status when template default status is null', () => {
      mockGetTemplateDefaultObject.mockReturnValue({
        status: null,
      })

      const { result } = renderHook(() => useVulnerabilityProductGenerator())
      const product = result.current.generateVulnerabilityProduct()

      expect(product.status).toBe('')
    })

    it('should use empty string for status when template default status is undefined', () => {
      mockGetTemplateDefaultObject.mockReturnValue({
        status: undefined,
      })

      const { result } = renderHook(() => useVulnerabilityProductGenerator())
      const product = result.current.generateVulnerabilityProduct()

      expect(product.status).toBe('')
    })

    it('should use empty string for status when template default status is empty string', () => {
      mockGetTemplateDefaultObject.mockReturnValue({
        status: '',
      })

      const { result } = renderHook(() => useVulnerabilityProductGenerator())
      const product = result.current.generateVulnerabilityProduct()

      expect(product.status).toBe('')
    })

    it('should generate different products with unique IDs on multiple calls', () => {
      mockUid
        .mockReturnValueOnce('uid-1')
        .mockReturnValueOnce('uid-2')
        .mockReturnValueOnce('uid-3')

      const { result } = renderHook(() => useVulnerabilityProductGenerator())

      const product1 = result.current.generateVulnerabilityProduct()
      const product2 = result.current.generateVulnerabilityProduct()
      const product3 = result.current.generateVulnerabilityProduct()

      expect(product1.id).toBe('uid-1')
      expect(product2.id).toBe('uid-2')
      expect(product3.id).toBe('uid-3')
      expect(mockUid).toHaveBeenCalledTimes(3)
    })

    it('should generate consistent structure across multiple calls', () => {
      mockGetTemplateDefaultObject.mockReturnValue({
        status: 'fixed',
      })

      const { result } = renderHook(() => useVulnerabilityProductGenerator())

      const product1 = result.current.generateVulnerabilityProduct()
      const product2 = result.current.generateVulnerabilityProduct()

      expect(product1).toHaveProperty('id')
      expect(product1).toHaveProperty('productId')
      expect(product1).toHaveProperty('status')
      expect(product2).toHaveProperty('id')
      expect(product2).toHaveProperty('productId')
      expect(product2).toHaveProperty('status')

      expect(product1.productId).toBe('')
      expect(product2.productId).toBe('')
      expect(product1.status).toBe('fixed')
      expect(product2.status).toBe('fixed')
    })

    it('should handle all valid template status values', () => {
      productStatus.forEach((status, index) => {
        mockGetTemplateDefaultObject.mockReturnValue({ status })
        mockUid.mockReturnValue(`uid-${index}`)

        const { result } = renderHook(() => useVulnerabilityProductGenerator())
        const product = result.current.generateVulnerabilityProduct()

        expect(product.status).toBe(status)
        expect(product.id).toBe(`uid-${index}`)
        expect(product.productId).toBe('')
      })
    })

    it('should handle template with extra properties', () => {
      mockGetTemplateDefaultObject.mockReturnValue({
        status: 'recommended',
        extraProperty: 'should be ignored',
        anotherProperty: 123,
      })

      const { result } = renderHook(() => useVulnerabilityProductGenerator())
      const product = result.current.generateVulnerabilityProduct()

      expect(product.status).toBe('recommended')
      expect(product).not.toHaveProperty('extraProperty')
      expect(product).not.toHaveProperty('anotherProperty')
    })

    it('should work when template returns complex object', () => {
      mockGetTemplateDefaultObject.mockReturnValue({
        status: 'under_investigation',
        nested: {
          property: 'value',
        },
        array: [1, 2, 3],
      })

      const { result } = renderHook(() => useVulnerabilityProductGenerator())
      const product = result.current.generateVulnerabilityProduct()

      expect(product.status).toBe('under_investigation')
      expect(product.id).toBe('mock-uid-123')
      expect(product.productId).toBe('')
      expect(Object.keys(product)).toEqual(['id', 'productId', 'status'])
    })
  })

  describe('integration tests', () => {
    it('should create valid TVulnerabilityProduct with generated function', () => {
      mockGetTemplateDefaultObject.mockReturnValue({
        status: 'known_not_affected',
      })
      mockUid.mockReturnValue('integration-test-id')

      const { result } = renderHook(() => useVulnerabilityProductGenerator())
      const product = result.current.generateVulnerabilityProduct()

      // Should be a valid TVulnerabilityProduct
      expect(product.id).toBe('integration-test-id')
      expect(product.productId).toBe('')
      expect(product.status).toBe('known_not_affected')

      // Should be assignable to TVulnerabilityProduct type
      const typedProduct: TVulnerabilityProduct = product
      expect(typedProduct).toEqual(product)
    })

    it('should demonstrate full workflow with different scenarios', () => {
      const scenarios = [
        { templateStatus: 'first_affected', expectedStatus: 'first_affected' },
        { templateStatus: '', expectedStatus: '' },
        { templateStatus: undefined, expectedStatus: '' },
        { templateStatus: null, expectedStatus: '' },
      ]

      scenarios.forEach(({ templateStatus, expectedStatus }, index) => {
        mockGetTemplateDefaultObject.mockReturnValue({
          status: templateStatus,
        })
        mockUid.mockReturnValue(`scenario-${index}-id`)

        const { result } = renderHook(() => useVulnerabilityProductGenerator())
        const product = result.current.generateVulnerabilityProduct()

        expect(product.id).toBe(`scenario-${index}-id`)
        expect(product.productId).toBe('')
        expect(product.status).toBe(expectedStatus)
      })
    })

    it('should work with rapid sequential generation', () => {
      mockGetTemplateDefaultObject.mockReturnValue({
        status: 'last_affected',
      })

      const { result } = renderHook(() => useVulnerabilityProductGenerator())
      const products: TVulnerabilityProduct[] = []

      for (let i = 0; i < 10; i++) {
        mockUid.mockReturnValue(`rapid-${i}`)
        products.push(result.current.generateVulnerabilityProduct())
      }

      expect(products).toHaveLength(10)
      products.forEach((product, index) => {
        expect(product.id).toBe(`rapid-${index}`)
        expect(product.productId).toBe('')
        expect(product.status).toBe('last_affected')
      })
    })

    it('should handle template service failures gracefully', () => {
      // When getTemplateDefaultObject returns null, accessing .status will throw
      // This tests the actual behavior - the implementation doesn't handle null gracefully
      mockGetTemplateDefaultObject.mockReturnValue(null)

      const { result } = renderHook(() => useVulnerabilityProductGenerator())
      
      expect(() => {
        result.current.generateVulnerabilityProduct()
      }).toThrow("Cannot read properties of null (reading 'status')")
    })
  })
})
