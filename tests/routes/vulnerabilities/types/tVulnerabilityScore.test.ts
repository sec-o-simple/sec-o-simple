import { describe, expect, it, vi } from 'vitest'

// Mock the uid function to make tests predictable
vi.mock('uid', () => ({
  uid: vi.fn(() => 'mocked-id-123'),
}))

// Import after mocking
import { uid } from 'uid'
import {
  getDefaultVulnerabilityScore,
  type TCvssVersion,
  type TVulnerabilityScore,
} from '../../../../src/routes/vulnerabilities/types/tVulnerabilityScore'

describe('tVulnerabilityScore Types and Functions', () => {
  describe('TCvssVersion Type', () => {
    it('should accept valid CVSS version strings', () => {
      const validVersions: TCvssVersion[] = ['3.0', '3.1', '4.0', null]

      validVersions.forEach((version) => {
        const score: TVulnerabilityScore = {
          id: 'test-id',
          cvssVersion: version,
          vectorString: 'test-vector',
          productIds: [],
        }
        expect(score.cvssVersion).toBe(version)
      })
    })

    it('should handle null version', () => {
      const nullVersion: TCvssVersion = null
      expect(nullVersion).toBeNull()
    })

    it('should handle all CVSS versions', () => {
      const version30: TCvssVersion = '3.0'
      const version31: TCvssVersion = '3.1'
      const version40: TCvssVersion = '4.0'

      expect(version30).toBe('3.0')
      expect(version31).toBe('3.1')
      expect(version40).toBe('4.0')
    })
  })

  describe('TVulnerabilityScore Type', () => {
    it('should create a valid vulnerability score object', () => {
      const score: TVulnerabilityScore = {
        id: 'test-id-123',
        cvssVersion: '3.1',
        vectorString: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
        productIds: ['product-1', 'product-2'],
      }

      expect(score.id).toBe('test-id-123')
      expect(score.cvssVersion).toBe('3.1')
      expect(score.vectorString).toBe(
        'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
      )
      expect(score.productIds).toEqual(['product-1', 'product-2'])
    })

    it('should handle empty arrays and null values', () => {
      const score: TVulnerabilityScore = {
        id: 'empty-test',
        cvssVersion: null,
        vectorString: '',
        productIds: [],
      }

      expect(score.id).toBe('empty-test')
      expect(score.cvssVersion).toBeNull()
      expect(score.vectorString).toBe('')
      expect(score.productIds).toEqual([])
      expect(score.productIds).toHaveLength(0)
    })

    it('should handle multiple product IDs', () => {
      const manyProductIds = ['prod-1', 'prod-2', 'prod-3', 'prod-4', 'prod-5']
      const score: TVulnerabilityScore = {
        id: 'multi-product-test',
        cvssVersion: '4.0',
        vectorString:
          'CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:H/VI:H/VA:H/SC:N/SI:N/SA:N',
        productIds: manyProductIds,
      }

      expect(score.productIds).toEqual(manyProductIds)
      expect(score.productIds).toHaveLength(5)
    })

    it('should validate all required fields are present', () => {
      const score: TVulnerabilityScore = {
        id: 'required-fields-test',
        cvssVersion: '3.0',
        vectorString: 'CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H',
        productIds: ['product-test'],
      }

      expect(score).toHaveProperty('id')
      expect(score).toHaveProperty('cvssVersion')
      expect(score).toHaveProperty('vectorString')
      expect(score).toHaveProperty('productIds')

      expect(typeof score.id).toBe('string')
      expect(typeof score.vectorString).toBe('string')
      expect(Array.isArray(score.productIds)).toBe(true)
    })
  })

  describe('getDefaultVulnerabilityScore Function', () => {
    it('should return a default vulnerability score object', () => {
      const defaultScore = getDefaultVulnerabilityScore()

      expect(defaultScore).toEqual({
        id: 'mocked-id-123',
        cvssVersion: null,
        vectorString: '',
        productIds: [],
      })
    })

    it('should generate unique IDs for each call', () => {
      // Mock uid to return different values
      vi.mocked(uid)
        .mockReturnValueOnce('id-1')
        .mockReturnValueOnce('id-2')
        .mockReturnValueOnce('id-3')

      const score1 = getDefaultVulnerabilityScore()
      const score2 = getDefaultVulnerabilityScore()
      const score3 = getDefaultVulnerabilityScore()

      expect(score1.id).toBe('id-1')
      expect(score2.id).toBe('id-2')
      expect(score3.id).toBe('id-3')
      expect(new Set([score1.id, score2.id, score3.id]).size).toBe(3)
    })

    it('should always return null for cvssVersion by default', () => {
      const score = getDefaultVulnerabilityScore()
      expect(score.cvssVersion).toBeNull()
    })

    it('should always return empty string for vectorString by default', () => {
      const score = getDefaultVulnerabilityScore()
      expect(score.vectorString).toBe('')
      expect(score.vectorString).toHaveLength(0)
    })

    it('should always return empty array for productIds by default', () => {
      const score = getDefaultVulnerabilityScore()
      expect(score.productIds).toEqual([])
      expect(score.productIds).toHaveLength(0)
      expect(Array.isArray(score.productIds)).toBe(true)
    })

    it('should call uid function to generate id', () => {
      vi.mocked(uid).mockReturnValue('test-generated-id')

      const score = getDefaultVulnerabilityScore()

      expect(uid).toHaveBeenCalled()
      expect(score.id).toBe('test-generated-id')
    })

    it('should return a new object each time (not the same reference)', () => {
      const score1 = getDefaultVulnerabilityScore()
      const score2 = getDefaultVulnerabilityScore()

      expect(score1).not.toBe(score2) // Different object references
      expect(score1.productIds).not.toBe(score2.productIds) // Different array references
    })

    it('should return an object that satisfies TVulnerabilityScore type', () => {
      const score = getDefaultVulnerabilityScore()

      // Type checking through property existence and types
      expect(typeof score.id).toBe('string')
      expect(
        score.cvssVersion === null || typeof score.cvssVersion === 'string',
      ).toBe(true)
      expect(typeof score.vectorString).toBe('string')
      expect(Array.isArray(score.productIds)).toBe(true)

      // Additional type validation for string arrays
      score.productIds.forEach((id) => {
        expect(typeof id).toBe('string')
      })
    })

    it('should handle multiple rapid calls without issues', () => {
      vi.mocked(uid).mockImplementation(() => Math.random().toString(36))

      const scores = Array.from({ length: 100 }, () =>
        getDefaultVulnerabilityScore(),
      )

      // All should be valid objects
      scores.forEach((score) => {
        expect(score).toHaveProperty('id')
        expect(score).toHaveProperty('cvssVersion')
        expect(score).toHaveProperty('vectorString')
        expect(score).toHaveProperty('productIds')
        expect(score.cvssVersion).toBeNull()
        expect(score.vectorString).toBe('')
        expect(score.productIds).toEqual([])
      })

      // All IDs should be defined (though they might not be unique due to Math.random)
      scores.forEach((score) => {
        expect(score.id).toBeDefined()
        expect(typeof score.id).toBe('string')
        expect(score.id.length).toBeGreaterThan(0)
      })
    })
  })

  describe('Integration Tests', () => {
    it('should work with all CVSS versions in a real-world scenario', () => {
      const cvssVersions: TCvssVersion[] = ['3.0', '3.1', '4.0', null]

      cvssVersions.forEach((version) => {
        const score = getDefaultVulnerabilityScore()
        score.cvssVersion = version

        if (version) {
          score.vectorString = `CVSS:${version}/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H`
        }

        expect(score.cvssVersion).toBe(version)
        expect(typeof score.id).toBe('string')
        expect(typeof score.vectorString).toBe('string')
        expect(Array.isArray(score.productIds)).toBe(true)
      })
    })

    it('should handle edge cases for vector strings', () => {
      const score = getDefaultVulnerabilityScore()

      // Test various vector string formats
      const vectorStrings = [
        '',
        'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
        'CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:H/VI:H/VA:H/SC:N/SI:N/SA:N',
        'invalid-vector-string',
        'CVSS:3.0/AV:L/AC:H/PR:H/UI:R/S:C/C:L/I:L/A:L',
      ]

      vectorStrings.forEach((vectorString) => {
        score.vectorString = vectorString
        expect(score.vectorString).toBe(vectorString)
      })
    })

    it('should handle edge cases for product IDs', () => {
      const score = getDefaultVulnerabilityScore()

      // Test various product ID scenarios
      const productIdSets = [
        [],
        ['single-product'],
        ['prod-1', 'prod-2'],
        ['product-with-dashes', 'product_with_underscores', 'ProductWithCaps'],
        Array.from({ length: 50 }, (_, i) => `product-${i}`), // Large array
      ]

      productIdSets.forEach((productIds) => {
        score.productIds = productIds
        expect(score.productIds).toEqual(productIds)
        expect(score.productIds).toHaveLength(productIds.length)
      })
    })
  })
})
