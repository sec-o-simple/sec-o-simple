import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import '@testing-library/jest-dom'
import VulnerabilityProduct from '../../../../src/routes/vulnerabilities/components/VulnerabilityProduct'
import { TVulnerabilityProduct, TProductStatus } from '../../../../src/routes/vulnerabilities/types/tVulnerabilityProduct'

// Mock functions that will be reassigned in tests
let mockGetGroupedSelectableRefs: any
let mockCheckReadOnly: any  
let mockGetPlaceholder: any

// Mock react-i18next
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => {
      const translations: Record<string, string> = {
        'vulnerabilities.products.status.known_affected': 'Known Affected',
        'vulnerabilities.products.status.known_not_affected': 'Known Not Affected',
        'vulnerabilities.products.status.fixed': 'Fixed',
        'vulnerabilities.products.status.under_investigation': 'Under Investigation',
        'products.product.label': 'Product',
        'products.relationship.categories.component_of': 'Component Of',
        'products.relationship.categories.contains': 'Contains',
        'products.relationship.categories.depends_on': 'Depends On',
        'products.relationship.categories.installed_on': 'Installed On',
        'products.relationship.categories.installed_with': 'Installed With',
      }
      return translations[key] || key
    },
  }),
}))

// Mock useProductTreeBranch hook
vi.mock('../../../../src/utils/useProductTreeBranch', () => ({
  useProductTreeBranch: () => ({
    getGroupedSelectableRefs: () => mockGetGroupedSelectableRefs(),
  }),
}))

// Mock template utilities
vi.mock('../../../../src/utils/template', () => ({
  checkReadOnly: (...args: any[]) => mockCheckReadOnly(...args),
  getPlaceholder: (...args: any[]) => mockGetPlaceholder(...args),
}))

// Mock HeroUI components with simplified versions
vi.mock('@heroui/react', () => ({
  AutocompleteSection: ({ children, title, classNames }: any) => (
    <div data-testid="autocomplete-section" data-title={title} className={classNames?.heading}>
      <div data-testid="section-title">{title}</div>
      {children}
    </div>
  ),
  AutocompleteItem: ({ children, classNames }: any) => (
    <div data-testid="autocomplete-item" className={classNames?.title}>
      {children}
    </div>
  ),
}))

vi.mock('@heroui/select', () => ({
  SelectItem: ({ children, ...props }: any) => {
    // Create reverse mapping from translated text to status key
    const statusMapping: Record<string, string> = {
      'Known Affected': 'known_affected',
      'Known Not Affected': 'known_not_affected', 
      'Fixed': 'fixed',
      'Under Investigation': 'under_investigation'
    }
    
    const value = statusMapping[children as string] || children
    return (
      <option data-testid="select-item" value={value} {...props}>{children}</option>
    )
  },
}))

// Mock form components with realistic behavior
vi.mock('../../../../src/components/forms/Autocomplete', () => ({
  Autocomplete: ({ 
    label, 
    selectedKey, 
    height, 
    onSelectionChange, 
    multiple, 
    isDisabled, 
    placeholder, 
    children 
  }: any) => (
    <div data-testid="autocomplete-component">
      <label data-testid="autocomplete-label">{label}</label>
      <input 
        data-testid="autocomplete-input"
        value={selectedKey || ''}
        onChange={(e) => onSelectionChange?.(e.target.value)}
        disabled={isDisabled}
        placeholder={placeholder}
        data-height={height}
        data-multiple={multiple}
      />
      <div data-testid="autocomplete-children">{children}</div>
    </div>
  ),
}))

vi.mock('../../../../src/components/forms/IconButton', () => ({
  default: ({ icon, onPress, isDisabled }: any) => (
    <button 
      data-testid="icon-button"
      onClick={onPress}
      disabled={isDisabled}
      data-icon={icon?.iconName || 'icon'}
    >
      Delete
    </button>
  ),
}))

vi.mock('../../../../src/components/forms/Select', () => ({
  default: ({ 
    label, 
    autoFocus, 
    selectionMode, 
    selectedKeys, 
    onSelectionChange, 
    maxListboxHeight, 
    className, 
    children 
  }: any) => {
    // Handle selectedKeys properly - it comes as an array from the component
    const keysArray = Array.isArray(selectedKeys) ? selectedKeys : (selectedKeys ? Array.from(selectedKeys) : [])
    const currentValue = keysArray.length > 0 ? String(keysArray[0]) : ''
    
    return (
      <div data-testid="select-component" className={`flex items-end gap-2 rounded-md border border-default-200 bg-zinc-50 p-4 ${className || ''}`}>
        <label data-testid="select-label">{label}</label>
        <select
          data-testid="select-input"
          value={currentValue}
          onChange={(e) => {
            const newValue = e.target.value
            if (onSelectionChange) {
              onSelectionChange(new Set([newValue]))
            }
          }}
          autoFocus={autoFocus}
          data-selection-mode={selectionMode}
          data-max-height={maxListboxHeight}
        >
          <option value="">Select option</option>
          {children}
        </select>
      </div>
    )
  },
}))

// Mock FontAwesome icons
vi.mock('@fortawesome/free-solid-svg-icons', () => ({
  faTrash: { iconName: 'trash' },
}))

// Test data
const mockVulnerabilityProduct: TVulnerabilityProduct = {
  id: 'vuln-product-1',
  productId: 'product-123',
  status: 'known_affected' as TProductStatus,
}

const mockGroupedSelectableRefs = {
  'component_of': [
    {
      full_product_name: {
        product_id: 'product-123',
        name: 'Test Product 1',
      },
    },
    {
      full_product_name: {
        product_id: 'product-456',
        name: 'Test Product 2',
      },
    },
  ],
  'contains': [
    {
      full_product_name: {
        product_id: 'product-789',
        name: 'Test Product 3',
      },
    },
  ],
}

describe('VulnerabilityProduct', () => {
  const mockOnChange = vi.fn()
  const mockOnDelete = vi.fn()

  beforeEach(() => {
    // Reset all mocks
    vi.clearAllMocks()
    
    // Setup fresh mock functions
    mockGetGroupedSelectableRefs = vi.fn().mockReturnValue(mockGroupedSelectableRefs)
    mockCheckReadOnly = vi.fn().mockReturnValue(false)
    mockGetPlaceholder = vi.fn().mockReturnValue('Select a product...')
  })

  describe('Component Rendering', () => {
    it('should render the VulnerabilityProduct component', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      expect(screen.getByTestId('select-component')).toBeInTheDocument()
      expect(screen.getByTestId('autocomplete-component')).toBeInTheDocument()
      expect(screen.getByTestId('icon-button')).toBeInTheDocument()
    })

    it('should render with correct container styling', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const container = screen.getByTestId('select-component')
      expect(container).toHaveClass('flex', 'items-end', 'gap-2', 'rounded-md', 'border', 'border-default-200', 'bg-zinc-50', 'p-4')
    })

    it('should render status select with correct label', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      expect(screen.getByTestId('select-label')).toHaveTextContent('Status')
    })

    it('should render status select with correct properties', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const selectComponent = screen.getByTestId('select-component')
      expect(selectComponent).toHaveClass('w-[450px]')
      
      const selectInput = screen.getByTestId('select-input')
      expect(selectInput).toHaveAttribute('data-selection-mode', 'single')
      expect(selectInput).toHaveAttribute('data-max-height', '300')
    })

    it('should render autocomplete with correct label', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      expect(screen.getByTestId('autocomplete-label')).toHaveTextContent('Product')
    })

    it('should render autocomplete with correct properties', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const autocompleteInput = screen.getByTestId('autocomplete-input')
      expect(autocompleteInput).toHaveAttribute('data-height', '600')
      expect(autocompleteInput).toHaveAttribute('data-multiple', 'true')
      expect(autocompleteInput).toHaveAttribute('placeholder', 'Select a product...')
    })

    it('should render delete button', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const deleteButton = screen.getByTestId('icon-button')
      expect(deleteButton).toBeInTheDocument()
      expect(deleteButton).toHaveAttribute('data-icon', 'trash')
      expect(deleteButton).toHaveTextContent('Delete')
    })
  })

  describe('Status Selection', () => {
    it('should display current status in select', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const selectInput = screen.getByTestId('select-input')
      expect(selectInput).toHaveValue('known_affected')
    })

    it('should render all allowed status options', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const statusOptions = screen.getAllByTestId('select-item')
      expect(statusOptions).toHaveLength(4)
      
      expect(statusOptions[0]).toHaveTextContent('Known Affected')
      expect(statusOptions[1]).toHaveTextContent('Known Not Affected')
      expect(statusOptions[2]).toHaveTextContent('Fixed')
      expect(statusOptions[3]).toHaveTextContent('Under Investigation')
    })

    it('should call onChange when status is changed', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const selectInput = screen.getByTestId('select-input')
      fireEvent.change(selectInput, { target: { value: 'fixed' } })

      expect(mockOnChange).toHaveBeenCalledWith({
        ...mockVulnerabilityProduct,
        status: 'fixed',
      })
    })

    it('should handle empty status change', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const selectInput = screen.getByTestId('select-input')
      fireEvent.change(selectInput, { target: { value: '' } })

      expect(mockOnChange).toHaveBeenCalledWith({
        ...mockVulnerabilityProduct,
        status: '',
      })
    })

    it('should work with different initial status values', () => {
      const productWithDifferentStatus = {
        ...mockVulnerabilityProduct,
        status: 'under_investigation' as TProductStatus,
      }

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={productWithDifferentStatus}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const selectInput = screen.getByTestId('select-input')
      expect(selectInput).toHaveValue('under_investigation')
    })
  })

  describe('Product Selection', () => {
    it('should display current product ID in autocomplete', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const autocompleteInput = screen.getByTestId('autocomplete-input')
      expect(autocompleteInput).toHaveValue('product-123')
    })

    it('should render grouped product options', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      // Check that both groups are rendered
      const sections = screen.getAllByTestId('autocomplete-section')
      expect(sections).toHaveLength(2)

      // Check section titles
      expect(screen.getByText('Component Of')).toBeInTheDocument()
      expect(screen.getByText('Contains')).toBeInTheDocument()

      // Check that all products are rendered
      const items = screen.getAllByTestId('autocomplete-item')
      expect(items).toHaveLength(3)
      expect(screen.getByText('Test Product 1')).toBeInTheDocument()
      expect(screen.getByText('Test Product 2')).toBeInTheDocument()
      expect(screen.getByText('Test Product 3')).toBeInTheDocument()
    })

    it('should render section with correct styling classes', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const sections = screen.getAllByTestId('autocomplete-section')
      expect(sections[0]).toHaveClass('sticky', 'top-1', 'z-20', 'flex', 'w-full', 'rounded-small', 'bg-default-100', 'px-2', 'py-1.5', 'shadow-small')
    })

    it('should render items with correct styling classes', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const items = screen.getAllByTestId('autocomplete-item')
      expect(items[0]).toHaveClass('text-wrap')
    })

    it('should call onChange when product is selected', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const autocompleteInput = screen.getByTestId('autocomplete-input')
      fireEvent.change(autocompleteInput, { target: { value: 'product-456' } })

      expect(mockOnChange).toHaveBeenCalledWith({
        ...mockVulnerabilityProduct,
        productId: 'product-456',
      })
    })

    it('should not call onChange when empty selection is made', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const autocompleteInput = screen.getByTestId('autocomplete-input')
      fireEvent.change(autocompleteInput, { target: { value: '' } })

      expect(mockOnChange).not.toHaveBeenCalled()
    })

    it('should handle disabled autocomplete', () => {
      mockCheckReadOnly = vi.fn().mockReturnValue(true)

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const autocompleteInput = screen.getByTestId('autocomplete-input')
      expect(autocompleteInput).toBeDisabled()
    })

    it('should display placeholder from template utility', () => {
      const customPlaceholder = 'Custom placeholder text'
      mockGetPlaceholder = vi.fn().mockReturnValue(customPlaceholder)

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const autocompleteInput = screen.getByTestId('autocomplete-input')
      expect(autocompleteInput).toHaveAttribute('placeholder', customPlaceholder)
    })
  })

  describe('Delete Functionality', () => {
    it('should call onDelete when delete button is clicked', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const deleteButton = screen.getByTestId('icon-button')
      fireEvent.click(deleteButton)

      expect(mockOnDelete).toHaveBeenCalledWith(mockVulnerabilityProduct)
    })

    it('should handle disabled delete button', () => {
      mockCheckReadOnly = vi.fn().mockReturnValue(true)

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const deleteButton = screen.getByTestId('icon-button')
      expect(deleteButton).toBeDisabled()
    })

    it('should work without onDelete callback', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
        />
      )

      const deleteButton = screen.getByTestId('icon-button')
      expect(() => fireEvent.click(deleteButton)).not.toThrow()
    })
  })

  describe('Edge Cases and Error Handling', () => {
    it('should work without onChange callback', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onDelete={mockOnDelete}
        />
      )

      const selectInput = screen.getByTestId('select-input')
      expect(() => fireEvent.change(selectInput, { target: { value: 'fixed' } })).not.toThrow()
    })

    it('should handle empty grouped selectable refs', () => {
      mockGetGroupedSelectableRefs = vi.fn().mockReturnValue({})

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      expect(screen.queryByTestId('autocomplete-section')).not.toBeInTheDocument()
    })

    it('should handle product with empty status', () => {
      const productWithEmptyStatus = {
        ...mockVulnerabilityProduct,
        status: '' as TProductStatus | '',
      }

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={productWithEmptyStatus}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const selectInput = screen.getByTestId('select-input')
      expect(selectInput).toHaveValue('')
    })

    it('should handle product with empty productId', () => {
      const productWithEmptyId = {
        ...mockVulnerabilityProduct,
        productId: '',
      }

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={productWithEmptyId}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const autocompleteInput = screen.getByTestId('autocomplete-input')
      expect(autocompleteInput).toHaveValue('')
    })

    it('should handle groups with empty product arrays', () => {
      const emptyGroupedRefs = {
        'component_of': [],
        'contains': [],
      }
      mockGetGroupedSelectableRefs = vi.fn().mockReturnValue(emptyGroupedRefs)

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const sections = screen.getAllByTestId('autocomplete-section')
      expect(sections).toHaveLength(2)
      expect(screen.queryByTestId('autocomplete-item')).not.toBeInTheDocument()
    })
  })

  describe('Template Integration', () => {
    it('should call checkReadOnly for productId field', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      expect(mockCheckReadOnly).toHaveBeenCalledWith(mockVulnerabilityProduct, 'productId')
    })

    it('should call checkReadOnly for delete button', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      expect(mockCheckReadOnly).toHaveBeenCalledWith(mockVulnerabilityProduct)
    })

    it('should call getPlaceholder for productId field', () => {
      render(
        <VulnerabilityProduct
          vulnerabilityProduct={mockVulnerabilityProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      expect(mockGetPlaceholder).toHaveBeenCalledWith(mockVulnerabilityProduct, 'productId')
    })
  })

  describe('Component State Management', () => {
    it('should preserve other properties when updating status', () => {
      const complexProduct = {
        ...mockVulnerabilityProduct,
        id: 'complex-id',
        productId: 'complex-product-id',
        status: 'known_affected' as TProductStatus,
      }

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={complexProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const selectInput = screen.getByTestId('select-input')
      fireEvent.change(selectInput, { target: { value: 'fixed' } })

      expect(mockOnChange).toHaveBeenCalledWith({
        id: 'complex-id',
        productId: 'complex-product-id',
        status: 'fixed',
      })
    })

    it('should preserve other properties when updating productId', () => {
      const complexProduct = {
        ...mockVulnerabilityProduct,
        id: 'complex-id',
        productId: 'old-product-id',
        status: 'under_investigation' as TProductStatus,
      }

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={complexProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      const autocompleteInput = screen.getByTestId('autocomplete-input')
      fireEvent.change(autocompleteInput, { target: { value: 'new-product-id' } })

      expect(mockOnChange).toHaveBeenCalledWith({
        id: 'complex-id',
        productId: 'new-product-id',
        status: 'under_investigation',
      })
    })
  })

  describe('Props Validation', () => {
    it('should handle props without optional callbacks', () => {
      expect(() => {
        render(
          <VulnerabilityProduct
            vulnerabilityProduct={mockVulnerabilityProduct}
          />
        )
      }).not.toThrow()
    })

    it('should handle different vulnerability product IDs', () => {
      const differentProduct = {
        ...mockVulnerabilityProduct,
        id: 'different-id',
        productId: 'different-product-id',
        status: 'fixed' as TProductStatus,
      }

      render(
        <VulnerabilityProduct
          vulnerabilityProduct={differentProduct}
          onChange={mockOnChange}
          onDelete={mockOnDelete}
        />
      )

      expect(screen.getByTestId('select-input')).toHaveValue('fixed')
      expect(screen.getByTestId('autocomplete-input')).toHaveValue('different-product-id')
    })
  })

  describe('Error Boundary Protection', () => {
    it('should handle missing grouped refs gracefully', () => {
      mockGetGroupedSelectableRefs = vi.fn().mockReturnValue(null)

      expect(() => {
        render(
          <VulnerabilityProduct
            vulnerabilityProduct={mockVulnerabilityProduct}
            onChange={mockOnChange}
            onDelete={mockOnDelete}
          />
        )
      }).toThrow() // This will throw due to Object.keys(null), which is expected behavior
    })

    it('should handle undefined grouped refs gracefully', () => {
      mockGetGroupedSelectableRefs = vi.fn().mockReturnValue(undefined)

      expect(() => {
        render(
          <VulnerabilityProduct
            vulnerabilityProduct={mockVulnerabilityProduct}
            onChange={mockOnChange}
            onDelete={mockOnDelete}
          />
        )
      }).toThrow() // This will throw due to Object.keys(undefined), which is expected behavior
    })
  })
})
