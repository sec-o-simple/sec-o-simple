import { describe, it, expect, vi, beforeEach } from 'vitest'
import { parseVulnerabilityProducts } from '../../../src/utils/csafImport/parseVulnerabilityProducts'
import { TProductStatus, TVulnerabilityProduct } from '../../../src/routes/vulnerabilities/types/tVulnerabilityProduct'

describe('parseVulnerabilityProducts', () => {
  const mockGenerateVulnerabilityProduct = vi.fn()

  const mockVulnerabilityProduct: TVulnerabilityProduct = {
    id: 'mock-vp-id',
    productId: '',
    status: '',
  }

  beforeEach(() => {
    vi.clearAllMocks()
    mockGenerateVulnerabilityProduct.mockReturnValue({ ...mockVulnerabilityProduct })
  })

  describe('Basic Functionality', () => {
    it('should return empty array when product status is undefined', () => {
      const result = parseVulnerabilityProducts(undefined as any, mockGenerateVulnerabilityProduct)
      expect(result).toEqual([])
      expect(mockGenerateVulnerabilityProduct).not.toHaveBeenCalled()
    })

    it('should return empty array when product status is null', () => {
      const result = parseVulnerabilityProducts(null as any, mockGenerateVulnerabilityProduct)
      expect(result).toEqual([])
      expect(mockGenerateVulnerabilityProduct).not.toHaveBeenCalled()
    })

    it('should return empty array when product status is empty object', () => {
      const productStatus = {}
      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)
      expect(result).toEqual([])
      expect(mockGenerateVulnerabilityProduct).not.toHaveBeenCalled()
    })

    it('should process single status with single product ID', () => {
      const productStatus = {
        known_affected: ['product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        ...mockVulnerabilityProduct,
        productId: 'product-1',
        status: 'known_affected',
      })
      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(1)
    })

    it('should process single status with multiple product IDs', () => {
      const productStatus = {
        fixed: ['product-1', 'product-2', 'product-3']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(3)
      expect(result[0]).toEqual({
        ...mockVulnerabilityProduct,
        productId: 'product-1',
        status: 'fixed',
      })
      expect(result[1]).toEqual({
        ...mockVulnerabilityProduct,
        productId: 'product-2',
        status: 'fixed',
      })
      expect(result[2]).toEqual({
        ...mockVulnerabilityProduct,
        productId: 'product-3',
        status: 'fixed',
      })
      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(3)
    })
  })

  describe('All Product Status Types', () => {
    it('should process known_affected status', () => {
      const productStatus = {
        known_affected: ['product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0].status).toBe('known_affected')
    })

    it('should process fixed status', () => {
      const productStatus = {
        fixed: ['product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0].status).toBe('fixed')
    })

    it('should process first_fixed status', () => {
      const productStatus = {
        first_fixed: ['product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0].status).toBe('first_fixed')
    })

    it('should process first_affected status', () => {
      const productStatus = {
        first_affected: ['product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0].status).toBe('first_affected')
    })

    it('should process known_not_affected status', () => {
      const productStatus = {
        known_not_affected: ['product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0].status).toBe('known_not_affected')
    })

    it('should process last_affected status', () => {
      const productStatus = {
        last_affected: ['product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0].status).toBe('last_affected')
    })

    it('should process recommended status', () => {
      const productStatus = {
        recommended: ['product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0].status).toBe('recommended')
    })

    it('should process under_investigation status', () => {
      const productStatus = {
        under_investigation: ['product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0].status).toBe('under_investigation')
    })

    it('should process all status types together', () => {
      const productStatus = {
        known_affected: ['ka-1', 'ka-2'],
        fixed: ['fixed-1'],
        first_fixed: ['ff-1'],
        first_affected: ['fa-1'],
        known_not_affected: ['kna-1'],
        last_affected: ['la-1'],
        recommended: ['rec-1'],
        under_investigation: ['ui-1', 'ui-2'],
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(10)
      
      // Verify known_affected products
      const knownAffected = result.filter(p => p.status === 'known_affected')
      expect(knownAffected).toHaveLength(2)
      expect(knownAffected[0].productId).toBe('ka-1')
      expect(knownAffected[1].productId).toBe('ka-2')

      // Verify other statuses
      expect(result.find(p => p.productId === 'fixed-1')?.status).toBe('fixed')
      expect(result.find(p => p.productId === 'ff-1')?.status).toBe('first_fixed')
      expect(result.find(p => p.productId === 'fa-1')?.status).toBe('first_affected')
      expect(result.find(p => p.productId === 'kna-1')?.status).toBe('known_not_affected')
      expect(result.find(p => p.productId === 'la-1')?.status).toBe('last_affected')
      expect(result.find(p => p.productId === 'rec-1')?.status).toBe('recommended')

      const underInvestigation = result.filter(p => p.status === 'under_investigation')
      expect(underInvestigation).toHaveLength(2)
      expect(underInvestigation[0].productId).toBe('ui-1')
      expect(underInvestigation[1].productId).toBe('ui-2')

      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(10)
    })
  })

  describe('Duplicate Product ID Handling', () => {
    it('should handle duplicate product IDs in same status by updating existing product', () => {
      const productStatus = {
        known_affected: ['product-1', 'product-1'] // Duplicate
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1) // Should only have one product
      expect(result[0]).toEqual({
        ...mockVulnerabilityProduct,
        productId: 'product-1',
        status: 'known_affected',
      })
      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(1) // Generator called only once
    })

    it('should handle duplicate product IDs across different statuses by updating status', () => {
      const productStatus = {
        known_affected: ['product-1'],
        fixed: ['product-1'] // Same product ID with different status
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1) // Should only have one product
      expect(result[0]).toEqual({
        ...mockVulnerabilityProduct,
        productId: 'product-1',
        status: 'fixed', // Should have the last processed status
      })
      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(1) // Generator called only once
    })

    it('should handle complex duplicate scenarios', () => {
      const productStatus = {
        known_affected: ['product-1', 'product-2'],
        fixed: ['product-2', 'product-3'], // product-2 is duplicate
        first_fixed: ['product-1', 'product-4'] // product-1 is duplicate
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(4) // product-1, product-2, product-3, product-4

      // product-1 should have first_fixed status (last processed)
      expect(result.find(p => p.productId === 'product-1')?.status).toBe('first_fixed')
      
      // product-2 should have fixed status (last processed)
      expect(result.find(p => p.productId === 'product-2')?.status).toBe('fixed')
      
      // product-3 should have fixed status
      expect(result.find(p => p.productId === 'product-3')?.status).toBe('fixed')
      
      // product-4 should have first_fixed status
      expect(result.find(p => p.productId === 'product-4')?.status).toBe('first_fixed')

      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(4)
    })
  })

  describe('Edge Cases', () => {
    it('should handle empty arrays in product status', () => {
      const productStatus = {
        known_affected: [],
        fixed: [],
        first_fixed: []
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toEqual([])
      expect(mockGenerateVulnerabilityProduct).not.toHaveBeenCalled()
    })

    it('should handle mixed empty and non-empty arrays', () => {
      const productStatus = {
        known_affected: [],
        fixed: ['product-1'],
        first_fixed: [],
        under_investigation: ['product-2']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(2)
      expect(result[0]).toEqual({
        ...mockVulnerabilityProduct,
        productId: 'product-1',
        status: 'fixed',
      })
      expect(result[1]).toEqual({
        ...mockVulnerabilityProduct,
        productId: 'product-2',
        status: 'under_investigation',
      })
      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(2)
    })

    it('should handle undefined arrays in product status', () => {
      const productStatus = {
        known_affected: undefined,
        fixed: ['product-1'],
        first_fixed: undefined
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        ...mockVulnerabilityProduct,
        productId: 'product-1',
        status: 'fixed',
      })
      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(1)
    })

    it('should handle empty string product IDs', () => {
      const productStatus = {
        known_affected: ['', 'product-1', '']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(2) // Two empty strings should result in one product due to deduplication
      
      const emptyIdProducts = result.filter(p => p.productId === '')
      expect(emptyIdProducts).toHaveLength(1)
      expect(emptyIdProducts[0].status).toBe('known_affected')

      const namedProduct = result.find(p => p.productId === 'product-1')
      expect(namedProduct).toBeDefined()
      expect(namedProduct?.status).toBe('known_affected')

      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(2)
    })

    it('should handle whitespace-only product IDs', () => {
      const productStatus = {
        fixed: ['  ', '\t', '\n', 'product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(4)
      expect(result.find(p => p.productId === '  ')?.status).toBe('fixed')
      expect(result.find(p => p.productId === '\t')?.status).toBe('fixed')
      expect(result.find(p => p.productId === '\n')?.status).toBe('fixed')
      expect(result.find(p => p.productId === 'product-1')?.status).toBe('fixed')
    })

    it('should handle very long product IDs', () => {
      const longProductId = 'a'.repeat(1000)
      const productStatus = {
        recommended: [longProductId]
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0].productId).toBe(longProductId)
      expect(result[0].status).toBe('recommended')
    })

    it('should handle special characters in product IDs', () => {
      const specialIds = [
        'product@#$%^&*()',
        'product-with-dashes',
        'product_with_underscores',
        'product.with.dots',
        'product/with/slashes',
        'product\\with\\backslashes',
        'product with spaces'
      ]

      const productStatus = {
        last_affected: specialIds
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(specialIds.length)
      specialIds.forEach(id => {
        const product = result.find(p => p.productId === id)
        expect(product).toBeDefined()
        expect(product?.status).toBe('last_affected')
      })
    })
  })

  describe('Generator Function Behavior', () => {
    it('should call generator function for each unique product', () => {
      const productStatus = {
        known_affected: ['product-1', 'product-2'],
        fixed: ['product-3']
      }

      parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(3)
    })

    it('should not call generator function for duplicate products', () => {
      const productStatus = {
        known_affected: ['product-1'],
        fixed: ['product-1'] // Duplicate
      }

      parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(mockGenerateVulnerabilityProduct).toHaveBeenCalledTimes(1)
    })

    it('should use generator return value correctly', () => {
      const customVulnerabilityProduct: TVulnerabilityProduct = {
        id: 'custom-id',
        productId: 'original-id',
        status: 'original-status' as TProductStatus,
      }

      mockGenerateVulnerabilityProduct.mockReturnValue(customVulnerabilityProduct)

      const productStatus = {
        fixed: ['new-product-id']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0]).toEqual({
        id: 'custom-id', // From generator
        productId: 'new-product-id', // Overridden by function
        status: 'fixed', // Overridden by function
      })
    })

    it('should handle generator function that returns different objects each time', () => {
      let callCount = 0
      mockGenerateVulnerabilityProduct.mockImplementation(() => ({
        id: `generated-id-${++callCount}`,
        productId: `generated-product-${callCount}`,
        status: '' as TProductStatus,
      }))

      const productStatus = {
        known_affected: ['product-1', 'product-2']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(2)
      expect(result[0].id).toBe('generated-id-1')
      expect(result[0].productId).toBe('product-1') // Overridden
      expect(result[1].id).toBe('generated-id-2')
      expect(result[1].productId).toBe('product-2') // Overridden
    })

    it('should handle generator function that throws error', () => {
      mockGenerateVulnerabilityProduct.mockImplementation(() => {
        throw new Error('Generator error')
      })

      const productStatus = {
        fixed: ['product-1']
      }

      expect(() => {
        parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)
      }).toThrow('Generator error')
    })
  })

  describe('Return Value Validation', () => {
    it('should always return an array', () => {
      const result1 = parseVulnerabilityProducts(undefined as any, mockGenerateVulnerabilityProduct)
      expect(Array.isArray(result1)).toBe(true)

      const result2 = parseVulnerabilityProducts({}, mockGenerateVulnerabilityProduct)
      expect(Array.isArray(result2)).toBe(true)

      const result3 = parseVulnerabilityProducts({ fixed: ['product-1'] }, mockGenerateVulnerabilityProduct)
      expect(Array.isArray(result3)).toBe(true)
    })

    it('should return array with correct structure for each product', () => {
      const productStatus = {
        known_affected: ['product-1']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      const product = result[0]
      
      expect(product).toHaveProperty('id')
      expect(product).toHaveProperty('productId')
      expect(product).toHaveProperty('status')
      expect(typeof product.id).toBe('string')
      expect(typeof product.productId).toBe('string')
      expect(typeof product.status).toBe('string')
    })

    it('should maintain object reference integrity', () => {
      const productStatus = {
        fixed: ['product-1', 'product-2']
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      // Each product should be a separate object
      expect(result[0]).not.toBe(result[1])
      expect(result[0]).not.toBe(mockVulnerabilityProduct)
      expect(result[1]).not.toBe(mockVulnerabilityProduct)
    })
  })

  describe('Order and Processing Sequence', () => {
    it('should process statuses in specific order', () => {
      const productStatus = {
        under_investigation: ['ui-product'],
        recommended: ['rec-product'],
        last_affected: ['la-product'],
        known_not_affected: ['kna-product'],
        first_affected: ['fa-product'],
        first_fixed: ['ff-product'],
        fixed: ['fixed-product'],
        known_affected: ['ka-product'],
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(8)

      // Verify that the order follows the function's processing order
      // (known_affected, fixed, first_fixed, first_affected, known_not_affected, last_affected, recommended, under_investigation)
      const expectedOrder = [
        { productId: 'ka-product', status: 'known_affected' },
        { productId: 'fixed-product', status: 'fixed' },
        { productId: 'ff-product', status: 'first_fixed' },
        { productId: 'fa-product', status: 'first_affected' },
        { productId: 'kna-product', status: 'known_not_affected' },
        { productId: 'la-product', status: 'last_affected' },
        { productId: 'rec-product', status: 'recommended' },
        { productId: 'ui-product', status: 'under_investigation' },
      ]

      expectedOrder.forEach((expected, index) => {
        expect(result[index].productId).toBe(expected.productId)
        expect(result[index].status).toBe(expected.status)
      })
    })

    it('should handle status override based on processing order', () => {
      // Same product appears in multiple statuses - later processed status should win
      const productStatus = {
        known_affected: ['product-1'], // Processed first
        under_investigation: ['product-1'] // Processed last - should override
      }

      const result = parseVulnerabilityProducts(productStatus, mockGenerateVulnerabilityProduct)

      expect(result).toHaveLength(1)
      expect(result[0].productId).toBe('product-1')
      expect(result[0].status).toBe('under_investigation') // Last processed status wins
    })
  })
})
