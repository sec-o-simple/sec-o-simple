import { TProductTreeBranch } from '@/routes/products/types/tProductTreeBranch'
import {
  getDefaultVulnerabilityProduct,
  TProductStatus,
  TVulnerabilityProduct,
} from '@/routes/vulnerabilities/types/tVulnerabilityProduct'
import { TCSAFDocument } from '../csafExport/csafExport'
import { IdGenerator } from './idGenerator'
import { getParentPTB } from './utils'

export function parseVulnerabilityProducts(
  productStatus: TCSAFDocument['vulnerabilities'][number]['product_status'],
  idGenerator: IdGenerator,
  sosPtbs: TProductTreeBranch[],
): TVulnerabilityProduct[] {
  let vulnerabilityProducts: TVulnerabilityProduct[] = []
  const addVulnerabilityProduct = (
    productId: string,
    versionId: string,
    status: TProductStatus,
  ) => {
    let previousVP = vulnerabilityProducts.find(
      (x) => x.productId === productId,
    )

    let newVP = previousVP
      ? previousVP
      : { ...getDefaultVulnerabilityProduct(), productId }

    newVP.versions = newVP.versions || []
    newVP.versions.push(versionId)
    newVP.status = status

    if (!previousVP) {
      vulnerabilityProducts.push(newVP)
    }
  }

  // All Status are imported, even if not used in the UI
  productStatus?.known_affected?.map((id) => {
    id.forEach((id) => {
      const ptbId = idGenerator.getId(id)
      const parentId = getParentPTB(ptbId, sosPtbs)?.id
      if (parentId) {
        addVulnerabilityProduct(parentId, ptbId, 'known_affected')
      }
    })
  })

  productStatus?.fixed?.map((id) => {
    id.forEach((id) => {
      const ptbId = idGenerator.getId(id)
      const parentId = getParentPTB(ptbId, sosPtbs)?.id
      if (parentId) {
        addVulnerabilityProduct(parentId, ptbId, 'fixed')
      }
    })
  })

  productStatus?.first_fixed?.map((id) => {
    id.forEach((id) => {
      const ptbId = idGenerator.getId(id)
      const parentId = getParentPTB(ptbId, sosPtbs)?.id
      if (parentId) {
        addVulnerabilityProduct(parentId, ptbId, 'first_fixed')
      }
    })
  })
  productStatus?.first_affected?.map((id) => {
    id.forEach((id) => {
      const ptbId = idGenerator.getId(id)
      debugger
      const parentId = getParentPTB(ptbId, sosPtbs)?.id
      if (parentId) {
        addVulnerabilityProduct(parentId, ptbId, 'first_affected')
      }
    })
  })
  productStatus?.known_not_affected?.map((id) => {
    id.forEach((id) => {
      const ptbId = idGenerator.getId(id)
      const parentId = getParentPTB(ptbId, sosPtbs)?.id
      if (parentId) {
        addVulnerabilityProduct(parentId, ptbId, 'known_not_affected')
      }
    })
  })
  productStatus?.last_affected?.map((id) => {
    id.forEach((id) => {
      const ptbId = idGenerator.getId(id)
      const parentId = getParentPTB(ptbId, sosPtbs)?.id
      if (parentId) {
        addVulnerabilityProduct(parentId, ptbId, 'last_affected')
      }
    })
  })
  productStatus?.recommended?.map((id) => {
    id.forEach((id) => {
      const ptbId = idGenerator.getId(id)
      const parentId = getParentPTB(ptbId, sosPtbs)?.id
      if (parentId) {
        addVulnerabilityProduct(parentId, ptbId, 'recommended')
      }
    })
  })
  productStatus?.under_investigation?.map((id) => {
    id.forEach((id) => {
      const ptbId = idGenerator.getId(id)
      const parentId = getParentPTB(ptbId, sosPtbs)?.id
      if (parentId) {
        addVulnerabilityProduct(parentId, ptbId, 'under_investigation')
      }
    })
  })

  return vulnerabilityProducts || []
}
